//
// This is a generated file, do not edit!
// Generated by R.swift, see https://github.com/mac-cain13/R.swift
//

import Foundation
import Rswift
import UIKit

/// This `R` struct is generated and contains references to static resources.
struct R: Rswift.Validatable {
  fileprivate static let applicationLocale = hostingBundle.preferredLocalizations.first.flatMap { Locale(identifier: $0) } ?? Locale.current
  fileprivate static let hostingBundle = Bundle(for: R.Class.self)

  /// Find first language and bundle for which the table exists
  fileprivate static func localeBundle(tableName: String, preferredLanguages: [String]) -> (Foundation.Locale, Foundation.Bundle)? {
    // Filter preferredLanguages to localizations, use first locale
    var languages = preferredLanguages
      .map { Locale(identifier: $0) }
      .prefix(1)
      .flatMap { locale -> [String] in
        if hostingBundle.localizations.contains(locale.identifier) {
          if let language = locale.languageCode, hostingBundle.localizations.contains(language) {
            return [locale.identifier, language]
          } else {
            return [locale.identifier]
          }
        } else if let language = locale.languageCode, hostingBundle.localizations.contains(language) {
          return [language]
        } else {
          return []
        }
      }

    // If there's no languages, use development language as backstop
    if languages.isEmpty {
      if let developmentLocalization = hostingBundle.developmentLocalization {
        languages = [developmentLocalization]
      }
    } else {
      // Insert Base as second item (between locale identifier and languageCode)
      languages.insert("Base", at: 1)

      // Add development language as backstop
      if let developmentLocalization = hostingBundle.developmentLocalization {
        languages.append(developmentLocalization)
      }
    }

    // Find first language for which table exists
    // Note: key might not exist in chosen language (in that case, key will be shown)
    for language in languages {
      if let lproj = hostingBundle.url(forResource: language, withExtension: "lproj"),
         let lbundle = Bundle(url: lproj)
      {
        let strings = lbundle.url(forResource: tableName, withExtension: "strings")
        let stringsdict = lbundle.url(forResource: tableName, withExtension: "stringsdict")

        if strings != nil || stringsdict != nil {
          return (Locale(identifier: language), lbundle)
        }
      }
    }

    // If table is available in main bundle, don't look for localized resources
    let strings = hostingBundle.url(forResource: tableName, withExtension: "strings", subdirectory: nil, localization: nil)
    let stringsdict = hostingBundle.url(forResource: tableName, withExtension: "stringsdict", subdirectory: nil, localization: nil)

    if strings != nil || stringsdict != nil {
      return (applicationLocale, hostingBundle)
    }

    // If table is not found for requested languages, key will be shown
    return nil
  }

  /// Load string from Info.plist file
  fileprivate static func infoPlistString(path: [String], key: String) -> String? {
    var dict = hostingBundle.infoDictionary
    for step in path {
      guard let obj = dict?[step] as? [String: Any] else { return nil }
      dict = obj
    }
    return dict?[key] as? String
  }

  static func validate() throws {
    try font.validate()
    try intern.validate()
  }

  #if os(iOS) || os(tvOS)
  /// This `R.storyboard` struct is generated, and contains static references to 3 storyboards.
  struct storyboard {
    /// Storyboard `Home`.
    static let home = _R.storyboard.home()
    /// Storyboard `LaunchScreen`.
    static let launchScreen = _R.storyboard.launchScreen()
    /// Storyboard `PopupStoryboard`.
    static let popupStoryboard = _R.storyboard.popupStoryboard()

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "Home", bundle: ...)`
    static func home(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.home)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "LaunchScreen", bundle: ...)`
    static func launchScreen(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.launchScreen)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIStoryboard(name: "PopupStoryboard", bundle: ...)`
    static func popupStoryboard(_: Void = ()) -> UIKit.UIStoryboard {
      return UIKit.UIStoryboard(resource: R.storyboard.popupStoryboard)
    }
    #endif

    fileprivate init() {}
  }
  #endif

  /// This `R.color` struct is generated, and contains static references to 13 colors.
  struct color {
    /// Color `AccentColor`.
    static let accentColor = Rswift.ColorResource(bundle: R.hostingBundle, name: "AccentColor")
    /// Color `active`.
    static let active = Rswift.ColorResource(bundle: R.hostingBundle, name: "active")
    /// Color `cellBackground`.
    static let cellBackground = Rswift.ColorResource(bundle: R.hostingBundle, name: "cellBackground")
    /// Color `correct`.
    static let correct = Rswift.ColorResource(bundle: R.hostingBundle, name: "correct")
    /// Color `daily`.
    static let daily = Rswift.ColorResource(bundle: R.hostingBundle, name: "daily")
    /// Color `incorrect`.
    static let incorrect = Rswift.ColorResource(bundle: R.hostingBundle, name: "incorrect")
    /// Color `mainBackground`.
    static let mainBackground = Rswift.ColorResource(bundle: R.hostingBundle, name: "mainBackground")
    /// Color `mainText`.
    static let mainText = Rswift.ColorResource(bundle: R.hostingBundle, name: "mainText")
    /// Color `monthly`.
    static let monthly = Rswift.ColorResource(bundle: R.hostingBundle, name: "monthly")
    /// Color `placeholder`.
    static let placeholder = Rswift.ColorResource(bundle: R.hostingBundle, name: "placeholder")
    /// Color `separatorLine`.
    static let separatorLine = Rswift.ColorResource(bundle: R.hostingBundle, name: "separatorLine")
    /// Color `unFocused`.
    static let unFocused = Rswift.ColorResource(bundle: R.hostingBundle, name: "unFocused")
    /// Color `weekly`.
    static let weekly = Rswift.ColorResource(bundle: R.hostingBundle, name: "weekly")

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "AccentColor", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func accentColor(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.accentColor, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "active", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func active(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.active, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "cellBackground", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func cellBackground(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.cellBackground, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "correct", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func correct(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.correct, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "daily", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func daily(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.daily, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "incorrect", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func incorrect(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.incorrect, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "mainBackground", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func mainBackground(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.mainBackground, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "mainText", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func mainText(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.mainText, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "monthly", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func monthly(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.monthly, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "placeholder", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func placeholder(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.placeholder, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "separatorLine", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func separatorLine(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.separatorLine, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "unFocused", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func unFocused(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.unFocused, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIColor(named: "weekly", bundle: ..., traitCollection: ...)`
    @available(tvOS 11.0, *)
    @available(iOS 11.0, *)
    static func weekly(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIColor? {
      return UIKit.UIColor(resource: R.color.weekly, compatibleWith: traitCollection)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "AccentColor", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func accentColor(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.accentColor.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "active", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func active(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.active.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "cellBackground", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func cellBackground(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.cellBackground.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "correct", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func correct(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.correct.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "daily", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func daily(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.daily.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "incorrect", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func incorrect(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.incorrect.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "mainBackground", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func mainBackground(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.mainBackground.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "mainText", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func mainText(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.mainText.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "monthly", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func monthly(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.monthly.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "placeholder", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func placeholder(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.placeholder.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "separatorLine", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func separatorLine(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.separatorLine.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "unFocused", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func unFocused(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.unFocused.name)
    }
    #endif

    #if os(watchOS)
    /// `UIColor(named: "weekly", bundle: ..., traitCollection: ...)`
    @available(watchOSApplicationExtension 4.0, *)
    static func weekly(_: Void = ()) -> UIKit.UIColor? {
      return UIKit.UIColor(named: R.color.weekly.name)
    }
    #endif

    fileprivate init() {}
  }

  /// This `R.file` struct is generated, and contains static references to 11 files.
  struct file {
    /// Resource file `GoogleService-Info.plist`.
    static let googleServiceInfoPlist = Rswift.FileResource(bundle: R.hostingBundle, name: "GoogleService-Info", pathExtension: "plist")
    /// Resource file `HindSiliguri-Bold.ttf`.
    static let hindSiliguriBoldTtf = Rswift.FileResource(bundle: R.hostingBundle, name: "HindSiliguri-Bold", pathExtension: "ttf")
    /// Resource file `HindSiliguri-Light.ttf`.
    static let hindSiliguriLightTtf = Rswift.FileResource(bundle: R.hostingBundle, name: "HindSiliguri-Light", pathExtension: "ttf")
    /// Resource file `HindSiliguri-Medium.ttf`.
    static let hindSiliguriMediumTtf = Rswift.FileResource(bundle: R.hostingBundle, name: "HindSiliguri-Medium", pathExtension: "ttf")
    /// Resource file `HindSiliguri-Regular.ttf`.
    static let hindSiliguriRegularTtf = Rswift.FileResource(bundle: R.hostingBundle, name: "HindSiliguri-Regular", pathExtension: "ttf")
    /// Resource file `HindSiliguri-SemiBold.ttf`.
    static let hindSiliguriSemiBoldTtf = Rswift.FileResource(bundle: R.hostingBundle, name: "HindSiliguri-SemiBold", pathExtension: "ttf")
    /// Resource file `TwitterHeartButton.json`.
    static let twitterHeartButtonJson = Rswift.FileResource(bundle: R.hostingBundle, name: "TwitterHeartButton", pathExtension: "json")
    /// Resource file `congratulation-badge-animation.json`.
    static let congratulationBadgeAnimationJson = Rswift.FileResource(bundle: R.hostingBundle, name: "congratulation-badge-animation", pathExtension: "json")
    /// Resource file `lf20_tiviyc3p.json`.
    static let lf20_tiviyc3pJson = Rswift.FileResource(bundle: R.hostingBundle, name: "lf20_tiviyc3p", pathExtension: "json")
    /// Resource file `oxford-5000.json`.
    static let oxford5000Json = Rswift.FileResource(bundle: R.hostingBundle, name: "oxford-5000", pathExtension: "json")
    /// Resource file `phrasal-verbs.json`.
    static let phrasalVerbsJson = Rswift.FileResource(bundle: R.hostingBundle, name: "phrasal-verbs", pathExtension: "json")

    /// `bundle.url(forResource: "GoogleService-Info", withExtension: "plist")`
    static func googleServiceInfoPlist(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.googleServiceInfoPlist
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "HindSiliguri-Bold", withExtension: "ttf")`
    static func hindSiliguriBoldTtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.hindSiliguriBoldTtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "HindSiliguri-Light", withExtension: "ttf")`
    static func hindSiliguriLightTtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.hindSiliguriLightTtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "HindSiliguri-Medium", withExtension: "ttf")`
    static func hindSiliguriMediumTtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.hindSiliguriMediumTtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "HindSiliguri-Regular", withExtension: "ttf")`
    static func hindSiliguriRegularTtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.hindSiliguriRegularTtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "HindSiliguri-SemiBold", withExtension: "ttf")`
    static func hindSiliguriSemiBoldTtf(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.hindSiliguriSemiBoldTtf
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "TwitterHeartButton", withExtension: "json")`
    static func twitterHeartButtonJson(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.twitterHeartButtonJson
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "congratulation-badge-animation", withExtension: "json")`
    static func congratulationBadgeAnimationJson(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.congratulationBadgeAnimationJson
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "lf20_tiviyc3p", withExtension: "json")`
    static func lf20_tiviyc3pJson(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.lf20_tiviyc3pJson
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "oxford-5000", withExtension: "json")`
    static func oxford5000Json(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.oxford5000Json
      return fileResource.bundle.url(forResource: fileResource)
    }

    /// `bundle.url(forResource: "phrasal-verbs", withExtension: "json")`
    static func phrasalVerbsJson(_: Void = ()) -> Foundation.URL? {
      let fileResource = R.file.phrasalVerbsJson
      return fileResource.bundle.url(forResource: fileResource)
    }

    fileprivate init() {}
  }

  /// This `R.font` struct is generated, and contains static references to 5 fonts.
  struct font: Rswift.Validatable {
    /// Font `HindSiliguri-Bold`.
    static let hindSiliguriBold = Rswift.FontResource(fontName: "HindSiliguri-Bold")
    /// Font `HindSiliguri-Light`.
    static let hindSiliguriLight = Rswift.FontResource(fontName: "HindSiliguri-Light")
    /// Font `HindSiliguri-Medium`.
    static let hindSiliguriMedium = Rswift.FontResource(fontName: "HindSiliguri-Medium")
    /// Font `HindSiliguri-Regular`.
    static let hindSiliguriRegular = Rswift.FontResource(fontName: "HindSiliguri-Regular")
    /// Font `HindSiliguri-SemiBold`.
    static let hindSiliguriSemiBold = Rswift.FontResource(fontName: "HindSiliguri-SemiBold")

    /// `UIFont(name: "HindSiliguri-Bold", size: ...)`
    static func hindSiliguriBold(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: hindSiliguriBold, size: size)
    }

    /// `UIFont(name: "HindSiliguri-Light", size: ...)`
    static func hindSiliguriLight(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: hindSiliguriLight, size: size)
    }

    /// `UIFont(name: "HindSiliguri-Medium", size: ...)`
    static func hindSiliguriMedium(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: hindSiliguriMedium, size: size)
    }

    /// `UIFont(name: "HindSiliguri-Regular", size: ...)`
    static func hindSiliguriRegular(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: hindSiliguriRegular, size: size)
    }

    /// `UIFont(name: "HindSiliguri-SemiBold", size: ...)`
    static func hindSiliguriSemiBold(size: CGFloat) -> UIKit.UIFont? {
      return UIKit.UIFont(resource: hindSiliguriSemiBold, size: size)
    }

    static func validate() throws {
      if R.font.hindSiliguriBold(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'HindSiliguri-Bold' could not be loaded, is 'HindSiliguri-Bold.ttf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.hindSiliguriLight(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'HindSiliguri-Light' could not be loaded, is 'HindSiliguri-Light.ttf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.hindSiliguriMedium(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'HindSiliguri-Medium' could not be loaded, is 'HindSiliguri-Medium.ttf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.hindSiliguriRegular(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'HindSiliguri-Regular' could not be loaded, is 'HindSiliguri-Regular.ttf' added to the UIAppFonts array in this targets Info.plist?") }
      if R.font.hindSiliguriSemiBold(size: 42) == nil { throw Rswift.ValidationError(description:"[R.swift] Font 'HindSiliguri-SemiBold' could not be loaded, is 'HindSiliguri-SemiBold.ttf' added to the UIAppFonts array in this targets Info.plist?") }
    }

    fileprivate init() {}
  }

  /// This `R.image` struct is generated, and contains static references to 34 images.
  struct image {
    /// Image `addRoundIcon`.
    static let addRoundIcon = Rswift.ImageResource(bundle: R.hostingBundle, name: "addRoundIcon")
    /// Image `arrowDropDown`.
    static let arrowDropDown = Rswift.ImageResource(bundle: R.hostingBundle, name: "arrowDropDown")
    /// Image `avatar`.
    static let avatar = Rswift.ImageResource(bundle: R.hostingBundle, name: "avatar")
    /// Image `backIcon`.
    static let backIcon = Rswift.ImageResource(bundle: R.hostingBundle, name: "backIcon")
    /// Image `bookCheckIcon`.
    static let bookCheckIcon = Rswift.ImageResource(bundle: R.hostingBundle, name: "bookCheckIcon")
    /// Image `bookIcon`.
    static let bookIcon = Rswift.ImageResource(bundle: R.hostingBundle, name: "bookIcon")
    /// Image `bookOpenIcon`.
    static let bookOpenIcon = Rswift.ImageResource(bundle: R.hostingBundle, name: "bookOpenIcon")
    /// Image `calendarIcon`.
    static let calendarIcon = Rswift.ImageResource(bundle: R.hostingBundle, name: "calendarIcon")
    /// Image `calendarLineIcon`.
    static let calendarLineIcon = Rswift.ImageResource(bundle: R.hostingBundle, name: "calendarLineIcon")
    /// Image `checkRoundFillIcon`.
    static let checkRoundFillIcon = Rswift.ImageResource(bundle: R.hostingBundle, name: "checkRoundFillIcon")
    /// Image `closeRoundFillIcon`.
    static let closeRoundFillIcon = Rswift.ImageResource(bundle: R.hostingBundle, name: "closeRoundFillIcon")
    /// Image `closeRoundIcon`.
    static let closeRoundIcon = Rswift.ImageResource(bundle: R.hostingBundle, name: "closeRoundIcon")
    /// Image `createDateIcon`.
    static let createDateIcon = Rswift.ImageResource(bundle: R.hostingBundle, name: "createDateIcon")
    /// Image `doneIcon`.
    static let doneIcon = Rswift.ImageResource(bundle: R.hostingBundle, name: "doneIcon")
    /// Image `folderIcon`.
    static let folderIcon = Rswift.ImageResource(bundle: R.hostingBundle, name: "folderIcon")
    /// Image `fullIcon`.
    static let fullIcon = Rswift.ImageResource(bundle: R.hostingBundle, name: "fullIcon")
    /// Image `happyFaceIcon`.
    static let happyFaceIcon = Rswift.ImageResource(bundle: R.hostingBundle, name: "happyFaceIcon")
    /// Image `logOutIcon`.
    static let logOutIcon = Rswift.ImageResource(bundle: R.hostingBundle, name: "logOutIcon")
    /// Image `moreActionIcon`.
    static let moreActionIcon = Rswift.ImageResource(bundle: R.hostingBundle, name: "moreActionIcon")
    /// Image `normal`.
    static let normal = Rswift.ImageResource(bundle: R.hostingBundle, name: "normal")
    /// Image `paperIcon`.
    static let paperIcon = Rswift.ImageResource(bundle: R.hostingBundle, name: "paperIcon")
    /// Image `pressed`.
    static let pressed = Rswift.ImageResource(bundle: R.hostingBundle, name: "pressed")
    /// Image `sadFaceIcon`.
    static let sadFaceIcon = Rswift.ImageResource(bundle: R.hostingBundle, name: "sadFaceIcon")
    /// Image `saveFillIcon`.
    static let saveFillIcon = Rswift.ImageResource(bundle: R.hostingBundle, name: "saveFillIcon")
    /// Image `searchTextIcon`.
    static let searchTextIcon = Rswift.ImageResource(bundle: R.hostingBundle, name: "searchTextIcon")
    /// Image `setIcon`.
    static let setIcon = Rswift.ImageResource(bundle: R.hostingBundle, name: "setIcon")
    /// Image `sortIcon`.
    static let sortIcon = Rswift.ImageResource(bundle: R.hostingBundle, name: "sortIcon")
    /// Image `sparklesIcon`.
    static let sparklesIcon = Rswift.ImageResource(bundle: R.hostingBundle, name: "sparklesIcon")
    /// Image `speakerIcon`.
    static let speakerIcon = Rswift.ImageResource(bundle: R.hostingBundle, name: "speakerIcon")
    /// Image `starIcon`.
    static let starIcon = Rswift.ImageResource(bundle: R.hostingBundle, name: "starIcon")
    /// Image `trashFillIcon`.
    static let trashFillIcon = Rswift.ImageResource(bundle: R.hostingBundle, name: "trashFillIcon")
    /// Image `trashLineIcon`.
    static let trashLineIcon = Rswift.ImageResource(bundle: R.hostingBundle, name: "trashLineIcon")
    /// Image `trophyIcon`.
    static let trophyIcon = Rswift.ImageResource(bundle: R.hostingBundle, name: "trophyIcon")
    /// Image `victoryIcon`.
    static let victoryIcon = Rswift.ImageResource(bundle: R.hostingBundle, name: "victoryIcon")

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "addRoundIcon", bundle: ..., traitCollection: ...)`
    static func addRoundIcon(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.addRoundIcon, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "arrowDropDown", bundle: ..., traitCollection: ...)`
    static func arrowDropDown(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.arrowDropDown, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "avatar", bundle: ..., traitCollection: ...)`
    static func avatar(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.avatar, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "backIcon", bundle: ..., traitCollection: ...)`
    static func backIcon(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.backIcon, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "bookCheckIcon", bundle: ..., traitCollection: ...)`
    static func bookCheckIcon(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.bookCheckIcon, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "bookIcon", bundle: ..., traitCollection: ...)`
    static func bookIcon(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.bookIcon, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "bookOpenIcon", bundle: ..., traitCollection: ...)`
    static func bookOpenIcon(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.bookOpenIcon, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "calendarIcon", bundle: ..., traitCollection: ...)`
    static func calendarIcon(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.calendarIcon, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "calendarLineIcon", bundle: ..., traitCollection: ...)`
    static func calendarLineIcon(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.calendarLineIcon, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "checkRoundFillIcon", bundle: ..., traitCollection: ...)`
    static func checkRoundFillIcon(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.checkRoundFillIcon, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "closeRoundFillIcon", bundle: ..., traitCollection: ...)`
    static func closeRoundFillIcon(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.closeRoundFillIcon, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "closeRoundIcon", bundle: ..., traitCollection: ...)`
    static func closeRoundIcon(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.closeRoundIcon, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "createDateIcon", bundle: ..., traitCollection: ...)`
    static func createDateIcon(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.createDateIcon, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "doneIcon", bundle: ..., traitCollection: ...)`
    static func doneIcon(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.doneIcon, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "folderIcon", bundle: ..., traitCollection: ...)`
    static func folderIcon(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.folderIcon, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "fullIcon", bundle: ..., traitCollection: ...)`
    static func fullIcon(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.fullIcon, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "happyFaceIcon", bundle: ..., traitCollection: ...)`
    static func happyFaceIcon(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.happyFaceIcon, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "logOutIcon", bundle: ..., traitCollection: ...)`
    static func logOutIcon(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.logOutIcon, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "moreActionIcon", bundle: ..., traitCollection: ...)`
    static func moreActionIcon(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.moreActionIcon, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "normal", bundle: ..., traitCollection: ...)`
    static func normal(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.normal, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "paperIcon", bundle: ..., traitCollection: ...)`
    static func paperIcon(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.paperIcon, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "pressed", bundle: ..., traitCollection: ...)`
    static func pressed(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.pressed, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "sadFaceIcon", bundle: ..., traitCollection: ...)`
    static func sadFaceIcon(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.sadFaceIcon, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "saveFillIcon", bundle: ..., traitCollection: ...)`
    static func saveFillIcon(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.saveFillIcon, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "searchTextIcon", bundle: ..., traitCollection: ...)`
    static func searchTextIcon(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.searchTextIcon, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "setIcon", bundle: ..., traitCollection: ...)`
    static func setIcon(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.setIcon, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "sortIcon", bundle: ..., traitCollection: ...)`
    static func sortIcon(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.sortIcon, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "sparklesIcon", bundle: ..., traitCollection: ...)`
    static func sparklesIcon(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.sparklesIcon, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "speakerIcon", bundle: ..., traitCollection: ...)`
    static func speakerIcon(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.speakerIcon, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "starIcon", bundle: ..., traitCollection: ...)`
    static func starIcon(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.starIcon, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "trashFillIcon", bundle: ..., traitCollection: ...)`
    static func trashFillIcon(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.trashFillIcon, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "trashLineIcon", bundle: ..., traitCollection: ...)`
    static func trashLineIcon(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.trashLineIcon, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "trophyIcon", bundle: ..., traitCollection: ...)`
    static func trophyIcon(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.trophyIcon, compatibleWith: traitCollection)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UIImage(named: "victoryIcon", bundle: ..., traitCollection: ...)`
    static func victoryIcon(compatibleWith traitCollection: UIKit.UITraitCollection? = nil) -> UIKit.UIImage? {
      return UIKit.UIImage(resource: R.image.victoryIcon, compatibleWith: traitCollection)
    }
    #endif

    fileprivate init() {}
  }

  /// This `R.info` struct is generated, and contains static references to 1 properties.
  struct info {
    struct uiApplicationSceneManifest {
      static let _key = "UIApplicationSceneManifest"
      static let uiApplicationSupportsMultipleScenes = false

      struct uiSceneConfigurations {
        static let _key = "UISceneConfigurations"

        struct uiWindowSceneSessionRoleApplication {
          struct defaultConfiguration {
            static let _key = "Default Configuration"
            static let uiSceneConfigurationName = infoPlistString(path: ["UIApplicationSceneManifest", "UISceneConfigurations", "UIWindowSceneSessionRoleApplication", "Default Configuration"], key: "UISceneConfigurationName") ?? "Default Configuration"
            static let uiSceneDelegateClassName = infoPlistString(path: ["UIApplicationSceneManifest", "UISceneConfigurations", "UIWindowSceneSessionRoleApplication", "Default Configuration"], key: "UISceneDelegateClassName") ?? "$(PRODUCT_MODULE_NAME).SceneDelegate"
            static let uiSceneStoryboardFile = infoPlistString(path: ["UIApplicationSceneManifest", "UISceneConfigurations", "UIWindowSceneSessionRoleApplication", "Default Configuration"], key: "UISceneStoryboardFile") ?? "Home"

            fileprivate init() {}
          }

          fileprivate init() {}
        }

        fileprivate init() {}
      }

      fileprivate init() {}
    }

    fileprivate init() {}
  }

  /// This `R.nib` struct is generated, and contains static references to 12 nibs.
  struct nib {
    /// Nib `IconTextView`.
    static let iconTextView = _R.nib._IconTextView()
    /// Nib `NoDataTableCell`.
    static let noDataTableCell = _R.nib._NoDataTableCell()
    /// Nib `PracticeDescriptionForm`.
    static let practiceDescriptionForm = _R.nib._PracticeDescriptionForm()
    /// Nib `PracticeTermForm`.
    static let practiceTermForm = _R.nib._PracticeTermForm()
    /// Nib `SetHeaderTableView`.
    static let setHeaderTableView = _R.nib._SetHeaderTableView()
    /// Nib `SignInNoteView`.
    static let signInNoteView = _R.nib._SignInNoteView()
    /// Nib `TermActivitiesTableCell`.
    static let termActivitiesTableCell = _R.nib._TermActivitiesTableCell()
    /// Nib `TermActivityCollectionCell`.
    static let termActivityCollectionCell = _R.nib._TermActivityCollectionCell()
    /// Nib `TextCollectionCell`.
    static let textCollectionCell = _R.nib._TextCollectionCell()
    /// Nib `TextTableCell`.
    static let textTableCell = _R.nib._TextTableCell()
    /// Nib `TopicInRoutineTableCell`.
    static let topicInRoutineTableCell = _R.nib._TopicInRoutineTableCell()
    /// Nib `TopicTableViewCell`.
    static let topicTableViewCell = _R.nib._TopicTableViewCell()

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "IconTextView", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.iconTextView) instead")
    static func iconTextView(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.iconTextView)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "NoDataTableCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.noDataTableCell) instead")
    static func noDataTableCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.noDataTableCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "PracticeDescriptionForm", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.practiceDescriptionForm) instead")
    static func practiceDescriptionForm(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.practiceDescriptionForm)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "PracticeTermForm", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.practiceTermForm) instead")
    static func practiceTermForm(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.practiceTermForm)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "SetHeaderTableView", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.setHeaderTableView) instead")
    static func setHeaderTableView(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.setHeaderTableView)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "SignInNoteView", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.signInNoteView) instead")
    static func signInNoteView(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.signInNoteView)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "TermActivitiesTableCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.termActivitiesTableCell) instead")
    static func termActivitiesTableCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.termActivitiesTableCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "TermActivityCollectionCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.termActivityCollectionCell) instead")
    static func termActivityCollectionCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.termActivityCollectionCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "TextCollectionCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.textCollectionCell) instead")
    static func textCollectionCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.textCollectionCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "TextTableCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.textTableCell) instead")
    static func textTableCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.textTableCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "TopicInRoutineTableCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.topicInRoutineTableCell) instead")
    static func topicInRoutineTableCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.topicInRoutineTableCell)
    }
    #endif

    #if os(iOS) || os(tvOS)
    /// `UINib(name: "TopicTableViewCell", in: bundle)`
    @available(*, deprecated, message: "Use UINib(resource: R.nib.topicTableViewCell) instead")
    static func topicTableViewCell(_: Void = ()) -> UIKit.UINib {
      return UIKit.UINib(resource: R.nib.topicTableViewCell)
    }
    #endif

    static func iconTextView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> IconTextView? {
      return R.nib.iconTextView.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? IconTextView
    }

    static func noDataTableCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> NoDataTableCell? {
      return R.nib.noDataTableCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? NoDataTableCell
    }

    static func practiceDescriptionForm(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> PracticeDescriptionForm? {
      return R.nib.practiceDescriptionForm.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? PracticeDescriptionForm
    }

    static func practiceTermForm(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> PracticeTermForm? {
      return R.nib.practiceTermForm.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? PracticeTermForm
    }

    static func setHeaderTableView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> SetHeaderTableView? {
      return R.nib.setHeaderTableView.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? SetHeaderTableView
    }

    static func signInNoteView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> SignInNoteView? {
      return R.nib.signInNoteView.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? SignInNoteView
    }

    static func termActivitiesTableCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> TermActivitiesTableCell? {
      return R.nib.termActivitiesTableCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? TermActivitiesTableCell
    }

    static func termActivityCollectionCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> TermActivityCollectionCell? {
      return R.nib.termActivityCollectionCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? TermActivityCollectionCell
    }

    static func textCollectionCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> TextCollectionCell? {
      return R.nib.textCollectionCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? TextCollectionCell
    }

    static func textTableCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> TextTableCell? {
      return R.nib.textTableCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? TextTableCell
    }

    static func topicInRoutineTableCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> TopicInRoutineTableCell? {
      return R.nib.topicInRoutineTableCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? TopicInRoutineTableCell
    }

    static func topicTableViewCell(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> TopicTableViewCell? {
      return R.nib.topicTableViewCell.instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? TopicTableViewCell
    }

    fileprivate init() {}
  }

  /// This `R.reuseIdentifier` struct is generated, and contains static references to 11 reuse identifiers.
  struct reuseIdentifier {
    /// Reuse identifier `HomeMenuTableViewCell`.
    static let homeMenuTableViewCell: Rswift.ReuseIdentifier<HomeMenuTableViewCell> = Rswift.ReuseIdentifier(identifier: "HomeMenuTableViewCell")
    /// Reuse identifier `LogoutTableCell`.
    static let logoutTableCell: Rswift.ReuseIdentifier<LogoutTableCell> = Rswift.ReuseIdentifier(identifier: "LogoutTableCell")
    /// Reuse identifier `NoDataTableCell`.
    static let noDataTableCell: Rswift.ReuseIdentifier<NoDataTableCell> = Rswift.ReuseIdentifier(identifier: "NoDataTableCell")
    /// Reuse identifier `PartOfSpeechTableCell`.
    static let partOfSpeechTableCell: Rswift.ReuseIdentifier<PartOfSpeechTableCell> = Rswift.ReuseIdentifier(identifier: "PartOfSpeechTableCell")
    /// Reuse identifier `PracticeResultTableViewCell`.
    static let practiceResultTableViewCell: Rswift.ReuseIdentifier<PracticeResultTableViewCell> = Rswift.ReuseIdentifier(identifier: "PracticeResultTableViewCell")
    /// Reuse identifier `ReviewCardCollectionCell`.
    static let reviewCardCollectionCell: Rswift.ReuseIdentifier<ReviewCardCollectionCell> = Rswift.ReuseIdentifier(identifier: "ReviewCardCollectionCell")
    /// Reuse identifier `SetTableViewCell`.
    static let setTableViewCell: Rswift.ReuseIdentifier<SetTableViewCell> = Rswift.ReuseIdentifier(identifier: "SetTableViewCell")
    /// Reuse identifier `TermCollectionCell`.
    static let termCollectionCell: Rswift.ReuseIdentifier<TermCollectionCell> = Rswift.ReuseIdentifier(identifier: "TermCollectionCell")
    /// Reuse identifier `TermTableCell`.
    static let termTableCell: Rswift.ReuseIdentifier<TermTableCell> = Rswift.ReuseIdentifier(identifier: "TermTableCell")
    /// Reuse identifier `TextTableCell`.
    static let textTableCell: Rswift.ReuseIdentifier<TextTableCell> = Rswift.ReuseIdentifier(identifier: "TextTableCell")
    /// Reuse identifier `UserAvatarAndUserNameCell`.
    static let userAvatarAndUserNameCell: Rswift.ReuseIdentifier<UserAvatarAndUserNameCell> = Rswift.ReuseIdentifier(identifier: "UserAvatarAndUserNameCell")

    fileprivate init() {}
  }

  /// This `R.string` struct is generated, and contains static references to 1 localization tables.
  struct string {
    /// This `R.string.localizable` struct is generated, and contains static references to 28 localization keys.
    struct localizable {
      /// en translation: All Topics
      ///
      /// Locales: en, vi
      static let all_topics = Rswift.StringResource(key: "all_topics", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "vi"], comment: nil)
      /// en translation: Create Folder
      ///
      /// Locales: en, vi
      static let create_new_folder = Rswift.StringResource(key: "create_new_folder", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "vi"], comment: nil)
      /// en translation: Data Format Not Available
      ///
      /// Locales: en, vi
      static let data_format_not_available = Rswift.StringResource(key: "data_format_not_available", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "vi"], comment: nil)
      /// en translation: Definition
      ///
      /// Locales: en, vi
      static let definition = Rswift.StringResource(key: "definition", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "vi"], comment: nil)
      /// en translation: Done
      ///
      /// Locales: en, vi
      static let done = Rswift.StringResource(key: "done", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "vi"], comment: nil)
      /// en translation: Email
      ///
      /// Locales: en, vi
      static let email = Rswift.StringResource(key: "email", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "vi"], comment: nil)
      /// en translation: Example
      ///
      /// Locales: en, vi
      static let example = Rswift.StringResource(key: "example", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "vi"], comment: nil)
      /// en translation: Favorite
      ///
      /// Locales: en, vi
      static let favorite = Rswift.StringResource(key: "favorite", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "vi"], comment: nil)
      /// en translation: Folder
      ///
      /// Locales: en, vi
      static let folder = Rswift.StringResource(key: "folder", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "vi"], comment: nil)
      /// en translation: Foleder Name
      ///
      /// Locales: en, vi
      static let folder_name = Rswift.StringResource(key: "folder_name", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "vi"], comment: nil)
      /// en translation: Logout
      ///
      /// Locales: en, vi
      static let logout = Rswift.StringResource(key: "logout", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "vi"], comment: nil)
      /// en translation: Or
      ///
      /// Locales: en, vi
      static let or = Rswift.StringResource(key: "or", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "vi"], comment: nil)
      /// en translation: Password
      ///
      /// Locales: en, vi
      static let password = Rswift.StringResource(key: "password", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "vi"], comment: nil)
      /// en translation: Quickly Sign In With
      ///
      /// Locales: en, vi
      static let quickly_signin_with = Rswift.StringResource(key: "quickly_signin_with", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "vi"], comment: nil)
      /// en translation: Review
      ///
      /// Locales: en, vi
      static let review = Rswift.StringResource(key: "review", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "vi"], comment: nil)
      /// en translation: Sign In
      ///
      /// Locales: en, vi
      static let signin = Rswift.StringResource(key: "signin", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "vi"], comment: nil)
      /// en translation: Sign In Success
      ///
      /// Locales: en, vi
      static let signin_success = Rswift.StringResource(key: "signin_success", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "vi"], comment: nil)
      /// en translation: Sign In With Email
      ///
      /// Locales: en, vi
      static let signin_with_email = Rswift.StringResource(key: "signin_with_email", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "vi"], comment: nil)
      /// en translation: Sign Up
      ///
      /// Locales: en, vi
      static let signup = Rswift.StringResource(key: "signup", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "vi"], comment: nil)
      /// en translation: Study
      ///
      /// Locales: en, vi
      static let study = Rswift.StringResource(key: "study", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "vi"], comment: nil)
      /// en translation: Studying
      ///
      /// Locales: en, vi
      static let studying = Rswift.StringResource(key: "studying", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "vi"], comment: nil)
      /// en translation: Term
      ///
      /// Locales: en, vi
      static let term = Rswift.StringResource(key: "term", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "vi"], comment: nil)
      /// en translation: Test
      ///
      /// Locales: en, vi
      static let test = Rswift.StringResource(key: "test", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "vi"], comment: nil)
      /// en translation: Trash
      ///
      /// Locales: en, vi
      static let trash = Rswift.StringResource(key: "trash", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "vi"], comment: nil)
      /// en translation: Type folder name
      ///
      /// Locales: en, vi
      static let type_folder_name = Rswift.StringResource(key: "type_folder_name", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "vi"], comment: nil)
      /// en translation: Update Folder
      ///
      /// Locales: en, vi
      static let update_folder = Rswift.StringResource(key: "update_folder", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "vi"], comment: nil)
      /// en translation: Words
      ///
      /// Locales: en, vi
      static let words = Rswift.StringResource(key: "words", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "vi"], comment: nil)
      /// en translation: You are using app without signing in. You data is at risk of being lost
      ///
      /// Locales: en, vi
      static let signin_note = Rswift.StringResource(key: "signin_note", tableName: "Localizable", bundle: R.hostingBundle, locales: ["en", "vi"], comment: nil)

      /// en translation: All Topics
      ///
      /// Locales: en, vi
      static func all_topics(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("all_topics", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "all_topics"
        }

        return NSLocalizedString("all_topics", bundle: bundle, comment: "")
      }

      /// en translation: Create Folder
      ///
      /// Locales: en, vi
      static func create_new_folder(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("create_new_folder", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "create_new_folder"
        }

        return NSLocalizedString("create_new_folder", bundle: bundle, comment: "")
      }

      /// en translation: Data Format Not Available
      ///
      /// Locales: en, vi
      static func data_format_not_available(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("data_format_not_available", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "data_format_not_available"
        }

        return NSLocalizedString("data_format_not_available", bundle: bundle, comment: "")
      }

      /// en translation: Definition
      ///
      /// Locales: en, vi
      static func definition(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("definition", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "definition"
        }

        return NSLocalizedString("definition", bundle: bundle, comment: "")
      }

      /// en translation: Done
      ///
      /// Locales: en, vi
      static func done(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("done", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "done"
        }

        return NSLocalizedString("done", bundle: bundle, comment: "")
      }

      /// en translation: Email
      ///
      /// Locales: en, vi
      static func email(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("email", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "email"
        }

        return NSLocalizedString("email", bundle: bundle, comment: "")
      }

      /// en translation: Example
      ///
      /// Locales: en, vi
      static func example(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("example", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "example"
        }

        return NSLocalizedString("example", bundle: bundle, comment: "")
      }

      /// en translation: Favorite
      ///
      /// Locales: en, vi
      static func favorite(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("favorite", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "favorite"
        }

        return NSLocalizedString("favorite", bundle: bundle, comment: "")
      }

      /// en translation: Folder
      ///
      /// Locales: en, vi
      static func folder(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("folder", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "folder"
        }

        return NSLocalizedString("folder", bundle: bundle, comment: "")
      }

      /// en translation: Foleder Name
      ///
      /// Locales: en, vi
      static func folder_name(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("folder_name", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "folder_name"
        }

        return NSLocalizedString("folder_name", bundle: bundle, comment: "")
      }

      /// en translation: Logout
      ///
      /// Locales: en, vi
      static func logout(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("logout", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "logout"
        }

        return NSLocalizedString("logout", bundle: bundle, comment: "")
      }

      /// en translation: Or
      ///
      /// Locales: en, vi
      static func or(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("or", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "or"
        }

        return NSLocalizedString("or", bundle: bundle, comment: "")
      }

      /// en translation: Password
      ///
      /// Locales: en, vi
      static func password(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("password", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "password"
        }

        return NSLocalizedString("password", bundle: bundle, comment: "")
      }

      /// en translation: Quickly Sign In With
      ///
      /// Locales: en, vi
      static func quickly_signin_with(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("quickly_signin_with", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "quickly_signin_with"
        }

        return NSLocalizedString("quickly_signin_with", bundle: bundle, comment: "")
      }

      /// en translation: Review
      ///
      /// Locales: en, vi
      static func review(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("review", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "review"
        }

        return NSLocalizedString("review", bundle: bundle, comment: "")
      }

      /// en translation: Sign In
      ///
      /// Locales: en, vi
      static func signin(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("signin", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "signin"
        }

        return NSLocalizedString("signin", bundle: bundle, comment: "")
      }

      /// en translation: Sign In Success
      ///
      /// Locales: en, vi
      static func signin_success(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("signin_success", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "signin_success"
        }

        return NSLocalizedString("signin_success", bundle: bundle, comment: "")
      }

      /// en translation: Sign In With Email
      ///
      /// Locales: en, vi
      static func signin_with_email(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("signin_with_email", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "signin_with_email"
        }

        return NSLocalizedString("signin_with_email", bundle: bundle, comment: "")
      }

      /// en translation: Sign Up
      ///
      /// Locales: en, vi
      static func signup(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("signup", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "signup"
        }

        return NSLocalizedString("signup", bundle: bundle, comment: "")
      }

      /// en translation: Study
      ///
      /// Locales: en, vi
      static func study(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("study", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "study"
        }

        return NSLocalizedString("study", bundle: bundle, comment: "")
      }

      /// en translation: Studying
      ///
      /// Locales: en, vi
      static func studying(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("studying", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "studying"
        }

        return NSLocalizedString("studying", bundle: bundle, comment: "")
      }

      /// en translation: Term
      ///
      /// Locales: en, vi
      static func term(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("term", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "term"
        }

        return NSLocalizedString("term", bundle: bundle, comment: "")
      }

      /// en translation: Test
      ///
      /// Locales: en, vi
      static func test(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("test", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "test"
        }

        return NSLocalizedString("test", bundle: bundle, comment: "")
      }

      /// en translation: Trash
      ///
      /// Locales: en, vi
      static func trash(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("trash", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "trash"
        }

        return NSLocalizedString("trash", bundle: bundle, comment: "")
      }

      /// en translation: Type folder name
      ///
      /// Locales: en, vi
      static func type_folder_name(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("type_folder_name", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "type_folder_name"
        }

        return NSLocalizedString("type_folder_name", bundle: bundle, comment: "")
      }

      /// en translation: Update Folder
      ///
      /// Locales: en, vi
      static func update_folder(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("update_folder", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "update_folder"
        }

        return NSLocalizedString("update_folder", bundle: bundle, comment: "")
      }

      /// en translation: Words
      ///
      /// Locales: en, vi
      static func words(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("words", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "words"
        }

        return NSLocalizedString("words", bundle: bundle, comment: "")
      }

      /// en translation: You are using app without signing in. You data is at risk of being lost
      ///
      /// Locales: en, vi
      static func signin_note(preferredLanguages: [String]? = nil) -> String {
        guard let preferredLanguages = preferredLanguages else {
          return NSLocalizedString("signin_note", bundle: hostingBundle, comment: "")
        }

        guard let (_, bundle) = localeBundle(tableName: "Localizable", preferredLanguages: preferredLanguages) else {
          return "signin_note"
        }

        return NSLocalizedString("signin_note", bundle: bundle, comment: "")
      }

      fileprivate init() {}
    }

    fileprivate init() {}
  }

  fileprivate struct intern: Rswift.Validatable {
    fileprivate static func validate() throws {
      try _R.validate()
    }

    fileprivate init() {}
  }

  fileprivate class Class {}

  fileprivate init() {}
}

struct _R: Rswift.Validatable {
  static func validate() throws {
    #if os(iOS) || os(tvOS)
    try nib.validate()
    #endif
    #if os(iOS) || os(tvOS)
    try storyboard.validate()
    #endif
  }

  #if os(iOS) || os(tvOS)
  struct nib: Rswift.Validatable {
    static func validate() throws {
      try _IconTextView.validate()
      try _SetHeaderTableView.validate()
      try _SignInNoteView.validate()
      try _TopicTableViewCell.validate()
    }

    struct _IconTextView: Rswift.NibResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "IconTextView"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> IconTextView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? IconTextView
      }

      static func validate() throws {
        if UIKit.UIImage(named: "2", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named '2' is used in nib 'IconTextView', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
        }
      }

      fileprivate init() {}
    }

    struct _NoDataTableCell: Rswift.NibResourceType, Rswift.ReuseIdentifierType {
      typealias ReusableType = NoDataTableCell

      let bundle = R.hostingBundle
      let identifier = "NoDataTableCell"
      let name = "NoDataTableCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> NoDataTableCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? NoDataTableCell
      }

      fileprivate init() {}
    }

    struct _PracticeDescriptionForm: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "PracticeDescriptionForm"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> PracticeDescriptionForm? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? PracticeDescriptionForm
      }

      fileprivate init() {}
    }

    struct _PracticeTermForm: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "PracticeTermForm"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> PracticeTermForm? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? PracticeTermForm
      }

      fileprivate init() {}
    }

    struct _SetHeaderTableView: Rswift.NibResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "SetHeaderTableView"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> SetHeaderTableView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? SetHeaderTableView
      }

      static func validate() throws {
        if UIKit.UIImage(named: "folderIcon", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'folderIcon' is used in nib 'SetHeaderTableView', but couldn't be loaded.") }
        if UIKit.UIImage(named: "moreActionIcon", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'moreActionIcon' is used in nib 'SetHeaderTableView', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "mainText", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'mainText' is used in nib 'SetHeaderTableView', but couldn't be loaded.") }
        }
      }

      fileprivate init() {}
    }

    struct _SignInNoteView: Rswift.NibResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "SignInNoteView"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> SignInNoteView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? SignInNoteView
      }

      func secondView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> UIKit.UIView? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[1] as? UIKit.UIView
      }

      static func validate() throws {
        if #available(iOS 13.0, *) { if UIKit.UIImage(systemName: "multiply.circle.fill") == nil { throw Rswift.ValidationError(description: "[R.swift] System image named 'multiply.circle.fill' is used in nib 'SignInNoteView', but couldn't be loaded.") } }
        if #available(iOS 11.0, tvOS 11.0, *) {
        }
      }

      fileprivate init() {}
    }

    struct _TermActivitiesTableCell: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "TermActivitiesTableCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> TermActivitiesTableCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? TermActivitiesTableCell
      }

      fileprivate init() {}
    }

    struct _TermActivityCollectionCell: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "TermActivityCollectionCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> TermActivityCollectionCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? TermActivityCollectionCell
      }

      fileprivate init() {}
    }

    struct _TextCollectionCell: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "TextCollectionCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> TextCollectionCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? TextCollectionCell
      }

      fileprivate init() {}
    }

    struct _TextTableCell: Rswift.NibResourceType, Rswift.ReuseIdentifierType {
      typealias ReusableType = TextTableCell

      let bundle = R.hostingBundle
      let identifier = "TextTableCell"
      let name = "TextTableCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> TextTableCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? TextTableCell
      }

      fileprivate init() {}
    }

    struct _TopicInRoutineTableCell: Rswift.NibResourceType {
      let bundle = R.hostingBundle
      let name = "TopicInRoutineTableCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> TopicInRoutineTableCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? TopicInRoutineTableCell
      }

      fileprivate init() {}
    }

    struct _TopicTableViewCell: Rswift.NibResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "TopicTableViewCell"

      func firstView(owner ownerOrNil: AnyObject?, options optionsOrNil: [UINib.OptionsKey : Any]? = nil) -> TopicTableViewCell? {
        return instantiate(withOwner: ownerOrNil, options: optionsOrNil)[0] as? TopicTableViewCell
      }

      static func validate() throws {
        if UIKit.UIImage(named: "calendarLineIcon", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'calendarLineIcon' is used in nib 'TopicTableViewCell', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
        }
      }

      fileprivate init() {}
    }

    fileprivate init() {}
  }
  #endif

  #if os(iOS) || os(tvOS)
  struct storyboard: Rswift.Validatable {
    static func validate() throws {
      #if os(iOS) || os(tvOS)
      try home.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try launchScreen.validate()
      #endif
      #if os(iOS) || os(tvOS)
      try popupStoryboard.validate()
      #endif
    }

    #if os(iOS) || os(tvOS)
    struct home: Rswift.StoryboardResourceType, Rswift.Validatable {
      let allTopicsViewController = StoryboardViewControllerResource<AllTopicsViewController>(identifier: "AllTopicsViewController")
      let bundle = R.hostingBundle
      let folderViewController = StoryboardViewControllerResource<FolderViewController>(identifier: "FolderViewController")
      let launchViewController = StoryboardViewControllerResource<LaunchViewController>(identifier: "LaunchViewController")
      let learnTopicViewController = StoryboardViewControllerResource<LearnTopicViewController>(identifier: "LearnTopicViewController")
      let name = "Home"
      let newFolderInputViewController = StoryboardViewControllerResource<NewFolderInputViewController>(identifier: "NewFolderInputViewController")
      let partOfSpeechMenuViewController = StoryboardViewControllerResource<PartOfSpeechMenuViewController>(identifier: "PartOfSpeechMenuViewController")
      let practiceTopicViewController = StoryboardViewControllerResource<PracticeTopicViewController>(identifier: "PracticeTopicViewController")
      let reviewCardViewController = StoryboardViewControllerResource<ReviewCardViewController>(identifier: "ReviewCardViewController")
      let signInViewController = StoryboardViewControllerResource<SignInViewController>(identifier: "SignInViewController")
      let signUpViewController = StoryboardViewControllerResource<SignUpViewController>(identifier: "SignUpViewController")
      let termsViewController = StoryboardViewControllerResource<TermsViewController>(identifier: "TermsViewController")
      let testTopicViewController = StoryboardViewControllerResource<TestTopicViewController>(identifier: "TestTopicViewController")
      let topicsListViewController = StoryboardViewControllerResource<TopicsListViewController>(identifier: "TopicsListViewController")
      let userInfoViewController = StoryboardViewControllerResource<UserInfoViewController>(identifier: "UserInfoViewController")
      let viewController = StoryboardViewControllerResource<ViewController>(identifier: "ViewController")

      func allTopicsViewController(_: Void = ()) -> AllTopicsViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: allTopicsViewController)
      }

      func folderViewController(_: Void = ()) -> FolderViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: folderViewController)
      }

      func launchViewController(_: Void = ()) -> LaunchViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: launchViewController)
      }

      func learnTopicViewController(_: Void = ()) -> LearnTopicViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: learnTopicViewController)
      }

      func newFolderInputViewController(_: Void = ()) -> NewFolderInputViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: newFolderInputViewController)
      }

      func partOfSpeechMenuViewController(_: Void = ()) -> PartOfSpeechMenuViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: partOfSpeechMenuViewController)
      }

      func practiceTopicViewController(_: Void = ()) -> PracticeTopicViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: practiceTopicViewController)
      }

      func reviewCardViewController(_: Void = ()) -> ReviewCardViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: reviewCardViewController)
      }

      func signInViewController(_: Void = ()) -> SignInViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: signInViewController)
      }

      func signUpViewController(_: Void = ()) -> SignUpViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: signUpViewController)
      }

      func termsViewController(_: Void = ()) -> TermsViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: termsViewController)
      }

      func testTopicViewController(_: Void = ()) -> TestTopicViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: testTopicViewController)
      }

      func topicsListViewController(_: Void = ()) -> TopicsListViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: topicsListViewController)
      }

      func userInfoViewController(_: Void = ()) -> UserInfoViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: userInfoViewController)
      }

      func viewController(_: Void = ()) -> ViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: viewController)
      }

      static func validate() throws {
        if UIKit.UIImage(named: "createDateIcon", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'createDateIcon' is used in storyboard 'Home', but couldn't be loaded.") }
        if #available(iOS 13.0, *) { if UIKit.UIImage(systemName: "eye.fill") == nil { throw Rswift.ValidationError(description: "[R.swift] System image named 'eye.fill' is used in storyboard 'Home', but couldn't be loaded.") } }
        if UIKit.UIImage(named: "fullIcon", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'fullIcon' is used in storyboard 'Home', but couldn't be loaded.") }
        if UIKit.UIImage(named: "paperIcon", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'paperIcon' is used in storyboard 'Home', but couldn't be loaded.") }
        if UIKit.UIImage(named: "trashLineIcon", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'trashLineIcon' is used in storyboard 'Home', but couldn't be loaded.") }
        if UIKit.UIImage(named: "victoryIcon", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'victoryIcon' is used in storyboard 'Home', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "active", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'active' is used in storyboard 'Home', but couldn't be loaded.") }
          if UIKit.UIColor(named: "cellBackground", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'cellBackground' is used in storyboard 'Home', but couldn't be loaded.") }
          if UIKit.UIColor(named: "mainBackground", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'mainBackground' is used in storyboard 'Home', but couldn't be loaded.") }
          if UIKit.UIColor(named: "mainText", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'mainText' is used in storyboard 'Home', but couldn't be loaded.") }
        }
        if _R.storyboard.home().allTopicsViewController() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'allTopicsViewController' could not be loaded from storyboard 'Home' as 'AllTopicsViewController'.") }
        if _R.storyboard.home().folderViewController() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'folderViewController' could not be loaded from storyboard 'Home' as 'FolderViewController'.") }
        if _R.storyboard.home().launchViewController() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'launchViewController' could not be loaded from storyboard 'Home' as 'LaunchViewController'.") }
        if _R.storyboard.home().learnTopicViewController() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'learnTopicViewController' could not be loaded from storyboard 'Home' as 'LearnTopicViewController'.") }
        if _R.storyboard.home().newFolderInputViewController() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'newFolderInputViewController' could not be loaded from storyboard 'Home' as 'NewFolderInputViewController'.") }
        if _R.storyboard.home().partOfSpeechMenuViewController() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'partOfSpeechMenuViewController' could not be loaded from storyboard 'Home' as 'PartOfSpeechMenuViewController'.") }
        if _R.storyboard.home().practiceTopicViewController() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'practiceTopicViewController' could not be loaded from storyboard 'Home' as 'PracticeTopicViewController'.") }
        if _R.storyboard.home().reviewCardViewController() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'reviewCardViewController' could not be loaded from storyboard 'Home' as 'ReviewCardViewController'.") }
        if _R.storyboard.home().signInViewController() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'signInViewController' could not be loaded from storyboard 'Home' as 'SignInViewController'.") }
        if _R.storyboard.home().signUpViewController() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'signUpViewController' could not be loaded from storyboard 'Home' as 'SignUpViewController'.") }
        if _R.storyboard.home().termsViewController() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'termsViewController' could not be loaded from storyboard 'Home' as 'TermsViewController'.") }
        if _R.storyboard.home().testTopicViewController() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'testTopicViewController' could not be loaded from storyboard 'Home' as 'TestTopicViewController'.") }
        if _R.storyboard.home().topicsListViewController() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'topicsListViewController' could not be loaded from storyboard 'Home' as 'TopicsListViewController'.") }
        if _R.storyboard.home().userInfoViewController() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'userInfoViewController' could not be loaded from storyboard 'Home' as 'UserInfoViewController'.") }
        if _R.storyboard.home().viewController() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'viewController' could not be loaded from storyboard 'Home' as 'ViewController'.") }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct launchScreen: Rswift.StoryboardResourceWithInitialControllerType, Rswift.Validatable {
      typealias InitialController = UIKit.UIViewController

      let bundle = R.hostingBundle
      let name = "LaunchScreen"

      static func validate() throws {
        if #available(iOS 11.0, tvOS 11.0, *) {
        }
      }

      fileprivate init() {}
    }
    #endif

    #if os(iOS) || os(tvOS)
    struct popupStoryboard: Rswift.StoryboardResourceType, Rswift.Validatable {
      let bundle = R.hostingBundle
      let name = "PopupStoryboard"
      let practicalResultViewController = StoryboardViewControllerResource<PracticalResultViewController>(identifier: "PracticalResultViewController")
      let resultPopupViewController = StoryboardViewControllerResource<ResultPopupViewController>(identifier: "ResultPopupViewController")
      let turnResultPopup = StoryboardViewControllerResource<TurnResultPopup>(identifier: "TurnResultPopup")

      func practicalResultViewController(_: Void = ()) -> PracticalResultViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: practicalResultViewController)
      }

      func resultPopupViewController(_: Void = ()) -> ResultPopupViewController? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: resultPopupViewController)
      }

      func turnResultPopup(_: Void = ()) -> TurnResultPopup? {
        return UIKit.UIStoryboard(resource: self).instantiateViewController(withResource: turnResultPopup)
      }

      static func validate() throws {
        if UIKit.UIImage(named: "happyFaceIcon", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Image named 'happyFaceIcon' is used in storyboard 'PopupStoryboard', but couldn't be loaded.") }
        if #available(iOS 11.0, tvOS 11.0, *) {
          if UIKit.UIColor(named: "cellBackground", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'cellBackground' is used in storyboard 'PopupStoryboard', but couldn't be loaded.") }
          if UIKit.UIColor(named: "mainBackground", in: R.hostingBundle, compatibleWith: nil) == nil { throw Rswift.ValidationError(description: "[R.swift] Color named 'mainBackground' is used in storyboard 'PopupStoryboard', but couldn't be loaded.") }
        }
        if _R.storyboard.popupStoryboard().practicalResultViewController() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'practicalResultViewController' could not be loaded from storyboard 'PopupStoryboard' as 'PracticalResultViewController'.") }
        if _R.storyboard.popupStoryboard().resultPopupViewController() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'resultPopupViewController' could not be loaded from storyboard 'PopupStoryboard' as 'ResultPopupViewController'.") }
        if _R.storyboard.popupStoryboard().turnResultPopup() == nil { throw Rswift.ValidationError(description:"[R.swift] ViewController with identifier 'turnResultPopup' could not be loaded from storyboard 'PopupStoryboard' as 'TurnResultPopup'.") }
      }

      fileprivate init() {}
    }
    #endif

    fileprivate init() {}
  }
  #endif

  fileprivate init() {}
}
